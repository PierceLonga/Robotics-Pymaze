{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Maze Solver Started template for a MkDocs docs site on GH Pages - including CI Features How to use this project Follow the tutorial instructions Install and configure a new or existing project. Run it locally. Deploy it. Add a copy of this project to your repos View the live demo This site is hosted on GitHub Pages. See if you like it. Other themes are available - see the tutorial. The aim here is not be complete or explain all concepts. It is to provide a reference for common steps and choices needed when setting up a docs site, but still at a beginner-friendly level. This guide is based on the mkdocs.org tutorial. Introduction This is a left hand wall following Python Maze. First you must follow the left hand wall of the random maze to map every cell of the Maze Then you have to find the quickest way from the bottom right start, to the top left end. I used a blue arrow to map all the cells. Then I used a red square to show the quickest way out. This was a hard project to work on. I worked out the left wall following first but it was doubling back so it was not a good path. It was a bad path. I watched so many different tutorials maybe about 100 on how to do mazes, but there was hardly any that showed how to map the left hand wall, so I had to try so many different ways from lots of diffent tutorials and try different lists, 2D arrays, stack popping on and popping off different ways to sort. I learned alot but it took so much time to learn how to do this. I tried about 5 differnt versions before I finally got it to work properly and I used alot of the code from the first attempt that only mapped the left wall but doubled back. I used a long array which I learnt in one of the tutorials and had a list of all the cells, the position and where it repeated the position to know the path that was quickest in the end. I also had to put in an exception when it ran into a wall and could not go forward left or right it had to turn around and orient the direction to were it was in the maze. You have to import the library from the assessment document, otherwise the Pymaze wont work. You have to from Pymaze, import maze and the Agent which I called Robot. The agent tracks the path. You also have to use navigate to move around. You have to append the list for the positions and trace yout path. Mapping the Maze \"FinalPythonBlueAllCells.jpg\" Traversal \"FinalPythonRedLeftWall.jpg\" Both mapping and Traversal together \"Final all plus left.jpg\" Mapping Algorithm Your information can go here from pyamaze import agent, maze class Robot(agent): def look(self, direction): while (direction != self._orient): self._RCW() def turnLeft(self): direction = (self._orient - 1)%4 self.look(direction) def turnBack(self): self.turnLeft() self.turnLeft() def turnRight(self): self.turnBack() self.turnLeft() def forward(self): if self.blocked: raise Exception(\"Can't drive into a wall\") [ self.moveUp, self.moveRight, self.moveDown, self.moveLeft ][self._orient](None) @property def walls(self): return self._parentMaze.maze_map[self.position] @property def blocked(self): facing = [\"N\", \"E\", \"S\", \"W\"][self._orient] return self.walls[facing] == 0 def navigate(self): self.turnLeft() while self.blocked: self.turnRight() self.forward() def escape(self): path = [self.position] while self.position != (1, 1): self.navigate() path.append(self.position) return path def main(): # Create maze and robot m = maze(5, 5) m.CreateMaze(loadMaze=\"maze--2022-11-25--14-43-24.csv\") r = Robot(m, shape=\"arrow\") # Find the path out of the maze start = r.position p = r.escape() r.position = start # Show the path out of the maze r.footprints = True m.tracePath({ r: p }, delay=20) print(m.maze_map) m.run() if __name__ == \"__main__\": main() Traversal Algorithm Usage When you run the Pymaze the program makes a random 20 X 20 Maze The first the blue arrow starts at the bottom right of the Maze this is the Start position The blue arrow follows the left wall and moves forward until there is no left wall then it has to move either turn aound, go up, go down and put the position of the cell into the long array. It doubles back on it self alot and you can see the path because the arrow shows you the direction it has gone, you can track the path. Then the red square takes the quickest path and this happens very qickly because it dosent repeat any cells or tiles. At the end of the code I give you three options you can either have both the mapping and the traversing happening right after each other so the progam running all the parts of the code. You can comment out if you want to see just the mapping or just the quickest path. I put comments in the code so you would know which one works depending on what you want to look at. I would never use the Pymaze. I would not like to go in a real maze either because you might gets stuck, but I did learn that if you follow the left hand wall you will find the way out but it could take a very long time.","title":"Home"},{"location":"#maze-solver","text":"Started template for a MkDocs docs site on GH Pages - including CI","title":"Maze Solver"},{"location":"#features","text":"How to use this project Follow the tutorial instructions Install and configure a new or existing project. Run it locally. Deploy it. Add a copy of this project to your repos View the live demo This site is hosted on GitHub Pages. See if you like it. Other themes are available - see the tutorial. The aim here is not be complete or explain all concepts. It is to provide a reference for common steps and choices needed when setting up a docs site, but still at a beginner-friendly level. This guide is based on the mkdocs.org tutorial.","title":"Features"},{"location":"#introduction","text":"This is a left hand wall following Python Maze. First you must follow the left hand wall of the random maze to map every cell of the Maze Then you have to find the quickest way from the bottom right start, to the top left end. I used a blue arrow to map all the cells. Then I used a red square to show the quickest way out. This was a hard project to work on. I worked out the left wall following first but it was doubling back so it was not a good path. It was a bad path. I watched so many different tutorials maybe about 100 on how to do mazes, but there was hardly any that showed how to map the left hand wall, so I had to try so many different ways from lots of diffent tutorials and try different lists, 2D arrays, stack popping on and popping off different ways to sort. I learned alot but it took so much time to learn how to do this. I tried about 5 differnt versions before I finally got it to work properly and I used alot of the code from the first attempt that only mapped the left wall but doubled back. I used a long array which I learnt in one of the tutorials and had a list of all the cells, the position and where it repeated the position to know the path that was quickest in the end. I also had to put in an exception when it ran into a wall and could not go forward left or right it had to turn around and orient the direction to were it was in the maze. You have to import the library from the assessment document, otherwise the Pymaze wont work. You have to from Pymaze, import maze and the Agent which I called Robot. The agent tracks the path. You also have to use navigate to move around. You have to append the list for the positions and trace yout path.","title":"Introduction"},{"location":"#mapping-the-maze","text":"\"FinalPythonBlueAllCells.jpg\"","title":"Mapping the Maze"},{"location":"#traversal","text":"\"FinalPythonRedLeftWall.jpg\"","title":"Traversal"},{"location":"#both-mapping-and-traversal-together","text":"\"Final all plus left.jpg\"","title":"Both mapping and Traversal together"},{"location":"#mapping-algorithm","text":"Your information can go here from pyamaze import agent, maze class Robot(agent): def look(self, direction): while (direction != self._orient): self._RCW() def turnLeft(self): direction = (self._orient - 1)%4 self.look(direction) def turnBack(self): self.turnLeft() self.turnLeft() def turnRight(self): self.turnBack() self.turnLeft() def forward(self): if self.blocked: raise Exception(\"Can't drive into a wall\") [ self.moveUp, self.moveRight, self.moveDown, self.moveLeft ][self._orient](None) @property def walls(self): return self._parentMaze.maze_map[self.position] @property def blocked(self): facing = [\"N\", \"E\", \"S\", \"W\"][self._orient] return self.walls[facing] == 0 def navigate(self): self.turnLeft() while self.blocked: self.turnRight() self.forward() def escape(self): path = [self.position] while self.position != (1, 1): self.navigate() path.append(self.position) return path def main(): # Create maze and robot m = maze(5, 5) m.CreateMaze(loadMaze=\"maze--2022-11-25--14-43-24.csv\") r = Robot(m, shape=\"arrow\") # Find the path out of the maze start = r.position p = r.escape() r.position = start # Show the path out of the maze r.footprints = True m.tracePath({ r: p }, delay=20) print(m.maze_map) m.run() if __name__ == \"__main__\": main()","title":"Mapping Algorithm"},{"location":"#traversal-algorithm","text":"","title":"Traversal Algorithm"},{"location":"#usage","text":"When you run the Pymaze the program makes a random 20 X 20 Maze The first the blue arrow starts at the bottom right of the Maze this is the Start position The blue arrow follows the left wall and moves forward until there is no left wall then it has to move either turn aound, go up, go down and put the position of the cell into the long array. It doubles back on it self alot and you can see the path because the arrow shows you the direction it has gone, you can track the path. Then the red square takes the quickest path and this happens very qickly because it dosent repeat any cells or tiles. At the end of the code I give you three options you can either have both the mapping and the traversing happening right after each other so the progam running all the parts of the code. You can comment out if you want to see just the mapping or just the quickest path. I put comments in the code so you would know which one works depending on what you want to look at. I would never use the Pymaze. I would not like to go in a real maze either because you might gets stuck, but I did learn that if you follow the left hand wall you will find the way out but it could take a very long time.","title":"Usage"}]}